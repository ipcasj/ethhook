use axum::{Json, extract::State, http::StatusCode};
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use tracing::{debug, error};
use uuid::Uuid;
use validator::Validate;

use crate::auth::{AuthUser, generate_token, hash_password, verify_password};
use crate::config::Config;

/// Helper to parse SQLite datetime string
fn parse_sqlite_datetime(s: Option<&str>) -> chrono::DateTime<chrono::Utc> {
    s.and_then(|s| {
        chrono::NaiveDateTime::parse_from_str(s, "%Y-%m-%d %H:%M:%S")
            .ok()
            .and_then(|dt| dt.and_local_timezone(chrono::Utc).single())
    })
    .unwrap_or_else(chrono::Utc::now)
}

/// Request to register a new user
#[derive(Debug, Deserialize, Validate)]
pub struct RegisterRequest {
    #[validate(email(message = "Please enter a valid email address (e.g., user@example.com)"))]
    pub email: String,
    #[validate(length(
        min = 8,
        message = "Password must be at least 8 characters long for security"
    ))]
    pub password: String,
    #[validate(length(
        min = 1,
        max = 100,
        message = "Name must be between 1 and 100 characters"
    ))]
    pub name: String,
}

/// Request to login
#[derive(Debug, Deserialize, Validate)]
pub struct LoginRequest {
    #[validate(email(message = "Please enter a valid email address"))]
    pub email: String,
    #[validate(length(min = 1, message = "Password is required"))]
    pub password: String,
}

/// User response
#[derive(Debug, Serialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub name: String,
    pub is_admin: bool,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

/// Auth response with token
#[derive(Debug, Serialize)]
pub struct AuthResponse {
    pub user: UserResponse,
    pub token: String,
}

/// Error response
#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Register a new user
pub async fn register(
    State(pool): State<SqlitePool>,
    State(config): State<Config>,
    Json(payload): Json<RegisterRequest>,
) -> Result<Json<AuthResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    payload.validate().map_err(|e| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Validation error: {e}"),
            }),
        )
    })?;

    // Hash password
    let password_hash = hash_password(&payload.password).map_err(|e| {
        error!("Password hashing failed: {:?}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Unable to process your password. Please try again.".to_string(),
            }),
        )
    })?;

    // Insert user
    // Generate UUID for SQLite (no auto-generation)
    let user_id = Uuid::new_v4().to_string();
    debug!(
        "Attempting to create user with email: {}, name: {}, id: {}",
        payload.email, payload.name, user_id
    );
    let user = sqlx::query!(
        r#"
        INSERT INTO users (id, email, password_hash, full_name)
        VALUES (?, ?, ?, ?)
        RETURNING id, email, full_name as name, is_admin, created_at
        "#,
        user_id,
        payload.email,
        password_hash,
        payload.name
    )
    .fetch_one(&pool)
    .await
    .map_err(|e| {
        error!("Database error during user creation: {:?}", e);

        // Check for duplicate email constraint violation
        let error_message = if e.to_string().contains("duplicate key") && e.to_string().contains("users_email_key") {
            "An account with this email already exists. Please use a different email or try logging in.".to_string()
        } else {
            "Unable to create account. Please try again later.".to_string()
        };

        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: error_message,
            }),
        )
    })?;

    let user_id = user
        .id
        .ok_or_else(|| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Database returned null user ID".to_string(),
                }),
            )
        })
        .and_then(|s| {
            Uuid::parse_str(s.as_str()).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(ErrorResponse {
                        error: "Invalid user ID format".to_string(),
                    }),
                )
            })
        })?;

    // Generate JWT token
    let token = generate_token(
        user_id,
        user.email.clone(),
        user.is_admin.unwrap_or(0) != 0,
        &config.jwt_secret,
        config.jwt_expiration_hours,
    )
    .map_err(|e| {
        error!("Token generation failed: {:?}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Account created but unable to log you in. Please try logging in manually."
                    .to_string(),
            }),
        )
    })?;

    Ok(Json(AuthResponse {
        user: UserResponse {
            id: user_id,
            email: user.email.clone(),
            name: user.name.unwrap_or_default(),
            is_admin: user.is_admin.unwrap_or(0) != 0,
            created_at: parse_sqlite_datetime(user.created_at.as_deref()),
        },
        token,
    }))
}

/// Login user
pub async fn login(
    State(pool): State<SqlitePool>,
    State(config): State<Config>,
    Json(payload): Json<LoginRequest>,
) -> Result<Json<AuthResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    payload.validate().map_err(|e| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Validation error: {e}"),
            }),
        )
    })?;

    // Find user by email
    let user = sqlx::query!(
        r#"
        SELECT id, email, full_name as name, password_hash, is_admin, created_at
        FROM users
        WHERE email = ?
        "#,
        payload.email
    )
    .fetch_one(&pool)
    .await
    .map_err(|e| match e {
        sqlx::Error::RowNotFound => (
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: "Invalid email or password".to_string(),
            }),
        ),
        _ => (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {e}"),
            }),
        ),
    })?;

    // Verify password
    let is_valid = verify_password(&payload.password, &user.password_hash).map_err(|_| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        )
    })?;

    if !is_valid {
        return Err((
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: "Invalid email or password".to_string(),
            }),
        ));
    }

    let user_id = user
        .id
        .ok_or_else(|| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Database returned null user ID".to_string(),
                }),
            )
        })
        .and_then(|s| {
            Uuid::parse_str(s.as_str()).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(ErrorResponse {
                        error: "Invalid user ID format".to_string(),
                    }),
                )
            })
        })?;

    // Generate JWT token
    let token = generate_token(
        user_id,
        user.email.clone(),
        user.is_admin.unwrap_or(0) != 0,
        &config.jwt_secret,
        config.jwt_expiration_hours,
    )
    .map_err(|e| {
        error!("Token generation failed during login: {:?}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Login credentials verified but unable to create session. Please try again."
                    .to_string(),
            }),
        )
    })?;

    Ok(Json(AuthResponse {
        user: UserResponse {
            id: user_id,
            email: user.email.clone(),
            name: user.name.unwrap_or_default(),
            is_admin: user.is_admin.unwrap_or(0) != 0,
            created_at: parse_sqlite_datetime(user.created_at.as_deref()),
        },
        token,
    }))
}

/// Get user profile
pub async fn get_profile(
    State(pool): State<SqlitePool>,
    auth_user: AuthUser,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id_str = auth_user.user_id.to_string();
    let user = sqlx::query!(
        r#"
        SELECT id, email, full_name as name, is_admin, created_at
        FROM users
        WHERE id = ?
        "#,
        user_id_str
    )
    .fetch_one(&pool)
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch user: {e}"),
            }),
        )
    })?;

    let user_id = user
        .id
        .ok_or_else(|| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Database returned null user ID".to_string(),
                }),
            )
        })
        .and_then(|s| {
            Uuid::parse_str(s.as_str()).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(ErrorResponse {
                        error: "Invalid user ID format".to_string(),
                    }),
                )
            })
        })?;

    Ok(Json(UserResponse {
        id: user_id,
        email: user.email,
        name: user.name.unwrap_or_default(),
        is_admin: user.is_admin.unwrap_or(0) != 0,
        created_at: parse_sqlite_datetime(user.created_at.as_deref()),
    }))
}

/// Update user profile
#[derive(Debug, Deserialize, Validate)]
pub struct UpdateProfileRequest {
    #[validate(length(min = 1, message = "Name cannot be empty"))]
    pub name: String,
}

/// Update user profile
pub async fn update_profile(
    State(pool): State<SqlitePool>,
    auth_user: AuthUser,
    Json(payload): Json<UpdateProfileRequest>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    payload.validate().map_err(|e| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Validation error: {e}"),
            }),
        )
    })?;

    let name = payload.name.trim().to_string();
    if name.is_empty() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Name cannot be empty".to_string(),
            }),
        ));
    };

    let user_id_str = auth_user.user_id.to_string();
    let user = sqlx::query!(
        r#"
        UPDATE users
        SET full_name = ?, updated_at = datetime('now')
        WHERE id = ?
        RETURNING id, email, full_name as name, is_admin, created_at
        "#,
        name,
        user_id_str
    )
    .fetch_one(&pool)
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to update user: {e}"),
            }),
        )
    })?;

    let user_id = user
        .id
        .ok_or_else(|| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Database returned null user ID".to_string(),
                }),
            )
        })
        .and_then(|s| {
            Uuid::parse_str(s.as_str()).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(ErrorResponse {
                        error: "Invalid user ID format".to_string(),
                    }),
                )
            })
        })?;

    Ok(Json(UserResponse {
        id: user_id,
        email: user.email,
        name: user.name.unwrap_or_default(),
        is_admin: user.is_admin.unwrap_or(0) != 0,
        created_at: parse_sqlite_datetime(user.created_at.as_deref()),
    }))
}
