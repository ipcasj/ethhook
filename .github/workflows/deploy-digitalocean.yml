name: Deploy to DigitalOcean

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual triggering

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/ipcasj/ethhook

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest

    steps:
      - name: Check deployment configuration
        id: check-config
        run: |
          if [ -z "${{ secrets.DROPLET_HOST }}" ] || [ -z "${{ secrets.DROPLET_SSH_KEY }}" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Deployment skipped: DROPLET_HOST or DROPLET_SSH_KEY secrets not configured"
            echo ""
            echo "To enable automated deployment:"
            echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Add DROPLET_HOST (your server IP)"
            echo "3. Add DROPLET_SSH_KEY (your SSH private key)"
            exit 0
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "‚úì Deployment configuration found"
          fi

      - name: Checkout code
        if: steps.check-config.outputs.skip == 'false'
        uses: actions/checkout@v4

      - name: Setup SSH key
        if: steps.check-config.outputs.skip == 'false'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.DROPLET_HOST }} >> ~/.ssh/known_hosts

      - name: Configure firewall rules
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            echo "üî• Configuring firewall rules..."
            
            # Check if UFW is installed and active
            if command -v ufw >/dev/null 2>&1; then
              echo "UFW firewall detected"
              
              # Allow SSH (important - don't lock yourself out!)
              sudo ufw allow 22/tcp comment 'SSH'
              
              # Allow HTTP/HTTPS
              sudo ufw allow 80/tcp comment 'HTTP'
              sudo ufw allow 443/tcp comment 'HTTPS'
              
              # Allow EthHook service ports
              sudo ufw allow 3000/tcp comment 'EthHook Admin API'
              sudo ufw allow 3002/tcp comment 'EthHook UI'
              sudo ufw allow 8000/tcp comment 'Demo Webhook Receiver'
              sudo ufw allow 8080/tcp comment 'EthHook Pipeline Health'
              sudo ufw allow 8123/tcp comment 'ClickHouse HTTP'
              sudo ufw allow 9000/tcp comment 'ClickHouse Native'
              sudo ufw allow 9090/tcp comment 'Prometheus Metrics'
              
              # Enable UFW if not already enabled
              sudo ufw --force enable
              
              echo "‚úÖ UFW rules configured:"
              sudo ufw status numbered
            else
              echo "‚ö†Ô∏è  UFW not installed, checking iptables..."
              
              # If using iptables directly, allow the ports
              if command -v iptables >/dev/null 2>&1; then
                sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 3000 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 3002 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 8000 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 8080 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 8123 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 9000 -j ACCEPT
                sudo iptables -A INPUT -p tcp --dport 9090 -j ACCEPT
                
                # Save iptables rules
                if command -v netfilter-persistent >/dev/null 2>&1; then
                  sudo netfilter-persistent save
                elif [ -f /etc/debian_version ]; then
                  sudo iptables-save > /etc/iptables/rules.v4
                fi
                
                echo "‚úÖ iptables rules configured"
              else
                echo "‚ö†Ô∏è  No firewall detected - ports should be open by default"
              fi
            fi
            
            echo "‚úÖ Firewall configuration complete"
          EOF

      - name: Setup project directory on server
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            # Create project directory if it doesn't exist
            if [ ! -d ~/ethhook ]; then
              echo "Creating ~/ethhook directory..."
              mkdir -p ~/ethhook
              cd ~/ethhook
              git clone https://github.com/ipcasj/ethhook.git .
              echo "‚úÖ Repository cloned"
            else
              echo "‚úÖ Directory exists"
              cd ~/ethhook
              
              # CRITICAL: Reset any local changes that might block pull
              echo "Resetting local changes..."
              git fetch origin
              git reset --hard origin/main
              echo "‚úÖ Repository force-updated to origin/main"
              
              # Verify we're on the latest commit
              LOCAL_COMMIT=$(git rev-parse HEAD)
              REMOTE_COMMIT=$(git rev-parse origin/main)
              
              if [ "$LOCAL_COMMIT" = "$REMOTE_COMMIT" ]; then
                echo "‚úÖ Local matches remote: $LOCAL_COMMIT"
              else
                echo "‚ùå Commit mismatch!"
                echo "Local:  $LOCAL_COMMIT"
                echo "Remote: $REMOTE_COMMIT"
                exit 1
              fi
            fi
          EOF

      - name: Configure environment variables on server
        if: steps.check-config.outputs.skip == 'false'
        run: |
          # Create production .env file
          cat > /tmp/prod.env << 'PRODENV'
          # ETHHOOK PRODUCTION CONFIGURATION

          # Database
          DATABASE_URL=sqlite:/data/config.db
          DATABASE_MAX_CONNECTIONS=20
          DATABASE_MIN_CONNECTIONS=5

          # Environment
          ENVIRONMENT=production

          # Ethereum RPC (Mainnet)
          ETHEREUM_RPC_URL=https://eth-mainnet.g.alchemy.com/v2/xGCBQXSFxK8qbIwCcSaJW
          ETHEREUM_WS_URL=wss://eth-mainnet.g.alchemy.com/v2/xGCBQXSFxK8qbIwCcSaJW

          # L2 Chains
          ARBITRUM_RPC_URL=https://arb-mainnet.g.alchemy.com/v2/ddFFnbN_vc-tyIXEsIgzN
          ARBITRUM_WS_URL=wss://arb-mainnet.g.alchemy.com/v2/ddFFnbN_vc-tyIXEsIgzN

          OPTIMISM_RPC_URL=https://opt-mainnet.g.alchemy.com/v2/2wYIA1B8CW11Q9s9QSBUq
          OPTIMISM_WS_URL=wss://opt-mainnet.g.alchemy.com/v2/2wYIA1B8CW11Q9s9QSBUq

          BASE_RPC_URL=https://base-mainnet.g.alchemy.com/v2/Q5Todg2C3lLAHDaYBmS8a
          BASE_WS_URL=wss://base-mainnet.g.alchemy.com/v2/Q5Todg2C3lLAHDaYBmS8a

          # Security
          JWT_SECRET=o6MANa5PpM3GDXgwqxrOdaymq0PhMxKzFXjbdOJCy4
          JWT_EXPIRATION_HOURS=24

          # Service Configuration
          WORKER_COUNT=50
          RUST_LOG=info,ethhook=info,sqlx=warn

          # API
          API_HOST=0.0.0.0
          API_PORT=3000

          # Webhooks
          WEBHOOK_TIMEOUT_SECONDS=30
          WEBHOOK_MAX_RETRIES=5
          WEBHOOK_WORKER_THREADS=50

          # CORS
          CORS_ALLOWED_ORIGINS=*

          # Metrics
          PROMETHEUS_METRICS_PORT=9090

          # Grafana
          GRAFANA_PASSWORD=admin
          PRODENV

          # Add secret from GitHub Secrets
          echo "" >> /tmp/prod.env
          echo "# Secrets" >> /tmp/prod.env
          echo "CLICKHOUSE_PASSWORD=${{ secrets.CLICKHOUSE_PASSWORD }}" >> /tmp/prod.env

          # Verify file
          echo "üìù Production .env file created ($(wc -l < /tmp/prod.env) lines)"

          # Copy to server
          scp /tmp/prod.env ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }}:~/ethhook/.env

          # Verify on server
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            cd ~/ethhook
            
            if [ -f .env ]; then
              echo "‚úÖ .env file exists ($(wc -l < .env) lines)"
              echo "Key variables:"
              grep -E "^(DATABASE_URL|CLICKHOUSE_PASSWORD|JWT_SECRET|ETHEREUM_WS_URL)=" .env | sed 's/=.*/=***/'
            else
              echo "‚ùå .env file not found!"
              exit 1
            fi
          EOF

          # Cleanup
          rm /tmp/prod.env

          echo "‚úÖ Production environment configured"

      # Disabled: Using direct deployment instead of Docker registry
      # - name: Build and push Docker images
      #   if: steps.check-config.outputs.skip == 'false'
      #   run: |
      #     # Login to GitHub Container Registry
      #     echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      #
      #     # Build and push images
      #     echo "Building and pushing Docker images..."
      #     docker compose -f docker-compose.prod.yml build pipeline admin-api ui demo-webhook-receiver
      #     docker compose -f docker-compose.prod.yml push pipeline admin-api ui demo-webhook-receiver
      #
      #     echo "‚úÖ Docker images built and pushed"

      - name: Build images on server directly
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            cd ~/ethhook
            
            # CRITICAL: Stop and remove ALL containers first
            echo "Stopping all EthHook containers..."
            docker compose -f docker-compose.prod.yml down || true
            
            # Remove any orphaned containers
            docker ps -a | grep ethhook | awk '{print $1}' | xargs -r docker rm -f || true
            
            # Remove ALL ethhook images to prevent any caching
            echo "Removing all ethhook images..."
            docker images | grep ethhook | awk '{print $3}' | xargs -r docker rmi -f || true
            
            # Also remove any untagged images that might be used as cache
            docker image prune -f
            
            # Final verification: NO ethhook images should exist
            REMAINING=$(docker images | grep -c ethhook || true)
            if [ "$REMAINING" -ne 0 ]; then
              echo "‚ùå Warning: $REMAINING ethhook images still present!"
              docker images | grep ethhook
            else
              echo "‚úÖ All ethhook images successfully removed"
            fi
            
            # VERIFY: Check docker-compose.prod.yml has correct configuration
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Verifying docker-compose.prod.yml configuration..."
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # Show current git commit
            echo "Current commit: $(git rev-parse --short HEAD)"
            echo "Commit message: $(git log -1 --pretty=%B | head -1)"
            echo ""
            
            # Show the actual admin-api configuration
            echo "Current admin-api configuration in docker-compose.prod.yml:"
            grep -A 8 "^  admin-api:" docker-compose.prod.yml | head -9
            echo ""
            
            # Verify context
            if grep -A 8 "^  admin-api:" docker-compose.prod.yml | grep -q "context: ethhook-c"; then
              echo "‚úÖ Context is set to: ethhook-c"
            else
              echo "‚ùå Context is NOT set correctly!"
              echo "Expected: 'context: ethhook-c'"
              echo "Got:"
              grep -A 8 "^  admin-api:" docker-compose.prod.yml | grep "context:"
              exit 1
            fi
            
            # Verify dockerfile path
            if grep -A 8 "^  admin-api:" docker-compose.prod.yml | grep -q "dockerfile: ./docker/Dockerfile.admin-api"; then
              echo "‚úÖ Dockerfile path is: ./docker/Dockerfile.admin-api"
            else
              echo "‚ùå Dockerfile path is NOT set correctly!"
              echo "Expected: 'dockerfile: ./docker/Dockerfile.admin-api'"
              echo "Got:"
              grep -A 8 "^  admin-api:" docker-compose.prod.yml | grep "dockerfile:"
              exit 1
            fi
            
            # Verify pull_policy
            if grep -A 8 "^  admin-api:" docker-compose.prod.yml | grep -q "pull_policy: never"; then
              echo "‚úÖ Pull policy is: never"
            else
              echo "‚ö†Ô∏è  Pull policy is NOT 'never' (might use cached/registry image)"
              grep -A 8 "^  admin-api:" docker-compose.prod.yml | grep "pull_policy:"
            fi
            
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # VERIFY: Check which Dockerfile will be used
            echo "Verifying Dockerfile exists..."
            echo "Full path should be: $(pwd)/ethhook-c/docker/Dockerfile.admin-api"
            
            if [ -f "ethhook-c/docker/Dockerfile.admin-api" ]; then
              echo "‚úÖ C Dockerfile exists at correct path"
              echo "First line: $(head -1 ethhook-c/docker/Dockerfile.admin-api)"
              if head -5 ethhook-c/docker/Dockerfile.admin-api | grep -q "alpine"; then
                echo "‚úÖ Confirmed: C Dockerfile (Alpine-based)"
              else
                echo "‚ö†Ô∏è  Unexpected Dockerfile content!"
              fi
            else
              echo "‚ùå C Dockerfile NOT FOUND at ethhook-c/docker/Dockerfile.admin-api!"
              echo "Directory contents:"
              ls -la ethhook-c/docker/ || echo "Directory doesn't exist!"
              exit 1
            fi
            
            # Verify Dockerfile has /data directory creation
            echo "Checking Dockerfile content..."
            if grep -q "mkdir -p /data" ethhook-c/docker/Dockerfile.admin-api; then
              echo "‚úÖ Dockerfile contains /data directory creation"
            else
              echo "‚ùå Dockerfile missing /data directory creation!"
              exit 1
            fi
            
            # Build C admin-api image locally with verbose output
            echo "Building C admin-api image..."
            docker compose -f docker-compose.prod.yml build --no-cache --pull --progress=plain admin-api 2>&1 | tee /tmp/admin-api-build.log
            
            if [ $? -ne 0 ]; then
              echo "‚ùå Admin API build failed!"
              cat /tmp/admin-api-build.log
              exit 1
            fi
            
            # Verify build logs show C compilation (not Rust)
            if grep -q "CMakeLists.txt" /tmp/admin-api-build.log; then
              echo "‚úÖ Build logs confirm CMake compilation (C implementation)"
            else
              echo "‚ö†Ô∏è  Warning: CMakeLists.txt not found in build logs!"
            fi
            
            if grep -q "cargo build" /tmp/admin-api-build.log; then
              echo "‚ùå ERROR: Build logs show Rust compilation!"
              echo "This means the wrong Dockerfile is being used!"
              exit 1
            fi
            
            # Verify the image was actually created
            if ! docker images | grep -q "ethhook-admin-api"; then
              echo "‚ùå Admin API image not found after build!"
              docker images
              exit 1
            fi
            
            # Get image creation time to verify it's fresh
            IMAGE_CREATED=$(docker images ghcr.io/ipcasj/ethhook-admin-api:latest --format "{{.CreatedAt}}")
            echo "‚úÖ Admin API image created: $IMAGE_CREATED"
            
            # Verify it's the C implementation by checking image size (should be ~50MB, not 500MB for Rust)
            IMAGE_SIZE=$(docker images ghcr.io/ipcasj/ethhook-admin-api:latest --format "{{.Size}}")
            echo "Image size: $IMAGE_SIZE"
            if [[ "$IMAGE_SIZE" =~ "GB" ]] || [[ "$IMAGE_SIZE" =~ [5-9][0-9][0-9]MB ]]; then
              echo "‚ö†Ô∏è  Warning: Image seems too large for C implementation!"
              echo "Expected: ~50MB, Got: $IMAGE_SIZE"
            fi
            
            # Build other services
            docker compose -f docker-compose.prod.yml build pipeline ui demo-webhook-receiver
            
            echo "‚úÖ All images built successfully"
          EOF

      - name: Deploy services
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            cd ~/ethhook
            
            # Verify .env file exists and has content
            if [ -f .env ]; then
              echo "‚úÖ .env file exists ($(wc -l < .env) lines)"
              echo "Environment variables configured:"
              grep -E "^[A-Z_]+=" .env | sed 's/=.*/=***/'
            else
              echo "‚ùå .env file not found!"
              exit 1
            fi
            
            # Stop all services gracefully
            echo "Stopping existing services..."
            docker compose -f docker-compose.prod.yml down || true
            
            # Start ClickHouse first (it's a dependency)
            echo "Starting ClickHouse database..."
            docker compose -f docker-compose.prod.yml up -d clickhouse
            
            # Wait for ClickHouse to be healthy
            echo "Waiting for ClickHouse to be healthy..."
            sleep 10
            
            # Verify images are available
            echo "Checking available images..."
            docker images | grep ethhook
            
            # Start application services with verbose output
            echo "Starting application services..."
            if docker compose -f docker-compose.prod.yml up -d pipeline admin-api ui demo-webhook-receiver; then
              echo "‚úÖ Docker compose up completed"
            else
              echo "‚ùå Docker compose up failed!"
              echo "=== Docker Compose Logs ==="
              docker compose -f docker-compose.prod.yml logs
              exit 1
            fi
            
            # Check what was started
            echo ""
            echo "=== All Containers ==="
            docker ps -a
            
            echo ""
            echo "=== EthHook Containers ==="
            docker ps -a --filter "name=ethhook"
            
            echo ""
            echo "=== Docker Compose Services Status ==="
            docker compose -f docker-compose.prod.yml ps -a
            
            # If admin-api isn't running, show its logs
            if ! docker ps | grep -q "ethhook-admin-api"; then
              echo ""
              echo "‚ö†Ô∏è  Admin API not running - checking logs..."
              docker logs ethhook-admin-api 2>&1 || echo "No admin-api container found"
            fi
            
            echo "‚úÖ Services start command completed"
          EOF

      - name: Wait for services to be healthy
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            cd ~/ethhook
            
            echo "Waiting for services to become healthy..."
            sleep 15
            
            # Check service status with detailed output
            echo "=== Docker Compose Service Status ==="
            docker compose -f docker-compose.prod.yml ps -a
            
            echo ""
            echo "=== Running Containers ==="
            docker ps -a
            
            # Check if services are running
            if docker compose -f docker-compose.prod.yml ps | grep -q "Up"; then
              echo "‚úÖ Services are running"
            else
              echo "‚ùå Some services failed to start"
              echo ""
              echo "=== Service Logs (last 100 lines) ==="
              docker compose -f docker-compose.prod.yml logs --tail=100
              exit 1
            fi
          EOF

      - name: Verify API health
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            echo "Waiting for services to be fully ready..."
            
            # Retry logic for admin API health check (from within server)
            MAX_RETRIES=30
            RETRY_DELAY=5
            RETRY_COUNT=0
            
            echo "Checking admin API from localhost (will retry up to $MAX_RETRIES times)..."
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              # Check from localhost (inside the server)
              ADMIN_API_HEALTH=$(curl -f -s http://localhost:3000/health 2>/dev/null || echo "failed")
              
              if [ "$ADMIN_API_HEALTH" != "failed" ]; then
                echo "‚úÖ Admin API is healthy: $ADMIN_API_HEALTH"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Attempt $RETRY_COUNT/$MAX_RETRIES - Admin API not ready yet, waiting ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              else
                echo "‚ùå Admin API health check failed after $MAX_RETRIES attempts"
                echo ""
                echo "=== Admin API Logs (last 50 lines) ==="
                docker logs ethhook-admin-api --tail=50 2>&1
                echo ""
                echo "=== Docker Container Status ==="
                docker ps -a | grep ethhook
                echo ""
                echo "=== Network Connectivity Test ==="
                curl -v http://localhost:3000/health 2>&1 || echo "Connection failed"
                exit 1
              fi
            done

            # Check pipeline health (optional - non-blocking)
            echo ""
            echo "Checking pipeline service from localhost..."
            PIPELINE_HEALTH=$(curl -f -s http://localhost:8080/health 2>/dev/null || echo "failed")
            if [ "$PIPELINE_HEALTH" = "failed" ]; then
              echo "‚ö†Ô∏è  Pipeline health check failed (port 8080) - may still be starting or not exposed"
            else
              echo "‚úÖ Pipeline is healthy: $PIPELINE_HEALTH"
            fi
            
            echo ""
            echo "‚úÖ Health checks completed successfully"
          EOF

      - name: Seed database with demo users
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            cd ~/ethhook
            
            echo "üå± Seeding database with demo users..."
            
            # Check if bcrypt is installed in admin-api container
            if ! docker exec ethhook-admin-api python3 -c "import bcrypt" 2>/dev/null; then
              echo "Installing bcrypt in admin-api container..."
              docker exec ethhook-admin-api apk add --no-cache py3-bcrypt 2>/dev/null || \
              docker exec ethhook-admin-api pip3 install bcrypt 2>/dev/null || \
              echo "‚ö†Ô∏è  Could not install bcrypt, trying alternative method..."
            fi
            
            # Copy seed script and run it inside the container
            docker cp ethhook-c/scripts/seed_database.py ethhook-admin-api:/tmp/seed_database.py
            docker exec ethhook-admin-api python3 /tmp/seed_database.py /data/config.db
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Database seeded successfully"
            else
              echo "‚ö†Ô∏è  Database seeding failed (may already have users)"
            fi
          EOF

      - name: Cleanup old Docker images
        if: steps.check-config.outputs.skip == 'false'
        run: |
          ssh ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            # Remove dangling images to save space
            docker image prune -f
            echo "‚úÖ Cleaned up old Docker images"
          EOF

      - name: Deployment notification
        if: always() && steps.check-config.outputs.skip == 'false'
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment to DigitalOcean successful!"
            echo "üöÄ Services: pipeline, admin-api, ui, demo-webhook-receiver"
            echo "üåê Server: ${{ secrets.DROPLET_HOST }}"
            echo "üîó Production URL: ${{ secrets.PRODUCTION_URL }}"
          else
            echo "‚ùå Deployment failed. Check logs above."
          fi
